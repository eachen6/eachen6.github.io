<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ORACLE周函数</title>
    <url>/2020/12/16/ORACLE%E5%91%A8%E5%87%BD%E6%95%B0-0/</url>
    <content><![CDATA[<p>工作中经常需要做一些报表数据的统计，其中就包括以周为单位的统计，这里对oracle的相关周函数进行记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select</span><br><span class="line">       to_char(sysdate,&#39;W&#39;), --当天是当月是第几周</span><br><span class="line">       to_char(sysdate,&#39;WW&#39;), --每年1月1日时第一周第一天开始算,当前时间是当年第几周</span><br><span class="line">       to_char(sysdate,&#39;IW&#39;)  --当前时间是当年第几周（自然周）</span><br><span class="line"> from dual;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>经验积累</category>
      </categories>
      <tags>
        <tag>ORACLE</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown学习内容</title>
    <url>/2020/12/11/first-blog/</url>
    <content><![CDATA[<p>Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>
<p>相比WYSIWYG编辑器</p>
<p><strong>优点：</strong><br> 1、因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。<br> 2、操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可</p>
<p><strong>缺点：</strong><br> 1、需要记一些语法（当然，是很简单。五分钟学会）。<br> 2、有些平台不支持Markdown编辑模式。</p>
<p>还好，简书是支持Markdown编辑模式的。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开启方式：设置-&gt;默认编辑器-&gt;Markdown编辑器</span><br></pre></td></tr></table></figure>

<h1 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h1><p>在想要设置为标题的文字前面加#来表示<br> 一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。</p>
<p>注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><hr>
<h1 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h1><ul>
<li><h5 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h5></li>
</ul>
<p>要加粗的文字左右分别用两个*号包起来</p>
<ul>
<li><h5 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h5></li>
</ul>
<p>要倾斜的文字左右分别用一个*号包起来</p>
<ul>
<li><h5 id="斜体加粗"><a href="#斜体加粗" class="headerlink" title="斜体加粗"></a>斜体加粗</h5></li>
</ul>
<p>要倾斜和加粗的文字左右分别用三个*号包起来</p>
<ul>
<li><h5 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h5></li>
</ul>
<p>要加删除线的文字左右分别用两个~~号包起来</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*&#96;</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><strong>这是加粗的文字</strong><br> <em>这是倾斜的文字</em><br> <strong><em>这是斜体加粗的文字\</em></strong><br> <del>这是加删除线的文字</del></p>
<hr>
<h1 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h1><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;<br> n个…<br> 貌似可以一直加下去，但没神马卵用</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
<h1 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h1><p>三个或者三个以上的 - 或者 * 都可以。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure>

<p>效果如下：<br> 可以看到，显示效果是一样的。</p>
<hr>
<hr>
<hr>
<hr>
<h1 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h1><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![blockchain](https:&#x2F;&#x2F;ss0.bdstatic.com&#x2F;70cFvHSh_Q1YnxGkpoWK1HF6hhy&#x2F;it&#x2F;</span><br><span class="line">u&#x3D;702257389,1274025419&amp;fm&#x3D;27&amp;gp&#x3D;0.jpg &quot;区块链&quot;)</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6860761-fd2f51090a890873.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/550/format/webp" alt="img"></p>
<p>blockchain</p>
<p><strong>上传本地图片直接点击导航栏的图片标志，选择图片即可</strong></p>
<p>markdown格式追求的是简单、多平台统一。那么图片的存储就是一个问题，需要用图床，提供统一的外链，这样就不用在不同的平台去处理图片的问题了。才能做到书写一次，各处使用。<br> 关于图床的选择我写了一篇文章，对网上存在的各种方法做了总结，需要的朋友可以看看。<a href="https://www.jianshu.com/p/ea1eb11db63f">markdown图床</a></p>
<h1 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h1><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">title可加可不加</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[简书](http:&#x2F;&#x2F;jianshu.com)</span><br><span class="line">[百度](http:&#x2F;&#x2F;baidu.com)</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><a href="https://www.jianshu.com/u/1f5ac0cf6a8b">简书</a><br> <a href="https://links.jianshu.com/go?to=http://baidu.com">百度</a></p>
<p>注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;超链接地址&quot; target&#x3D;&quot;_blank&quot;&gt;超链接名&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">示例</span><br><span class="line">&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;1f5ac0cf6a8b&quot; target&#x3D;&quot;_blank&quot;&gt;简书&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h1><h5 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h5><p>语法：<br> 无序列表用 - + * 任何一种都可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line"></span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<ul>
<li>列表内容</li>
<li>列表内容</li>
<li>列表内容</li>
</ul>
<h5 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h5><p>语法：<br> 数字加点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 列表内容</span><br><span class="line">2. 列表内容</span><br><span class="line">3. 列表内容</span><br><span class="line"></span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<ol>
<li>列表内容</li>
<li>列表内容</li>
<li>列表内容</li>
</ol>
<h5 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h5><p><strong>上一级和下一级之间敲三个空格即可</strong></p>
<ul>
<li>一级无序列表内容<ul>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
</ul>
</li>
<li>一级无序列表内容<ol>
<li>二级有序列表内容</li>
<li>二级有序列表内容</li>
<li>二级有序列表内容</li>
</ol>
</li>
</ul>
<ol>
<li>一级有序列表内容<ul>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
</ul>
</li>
<li>一级有序列表内容<ol>
<li>二级有序列表内容</li>
<li>二级有序列表内容</li>
<li>二级有序列表内容</li>
</ol>
</li>
</ol>
<hr>
<h1 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h1><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line">- 有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br><span class="line">注：原生的语法两边都要用 | 包起来。此处省略</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">姓名|技能|排行</span><br><span class="line">--|:--:|--:</span><br><span class="line">刘备|哭|大哥</span><br><span class="line">关羽|打|二哥</span><br><span class="line">张飞|骂|三弟</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<table>
<thead>
<tr>
<th>姓名</th>
<th align="center">技能</th>
<th align="right">排行</th>
</tr>
</thead>
<tbody><tr>
<td>刘备</td>
<td align="center">哭</td>
<td align="right">大哥</td>
</tr>
<tr>
<td>关羽</td>
<td align="center">打</td>
<td align="right">二哥</td>
</tr>
<tr>
<td>张飞</td>
<td align="center">骂</td>
<td align="right">三弟</td>
</tr>
</tbody></table>
<h1 id="九、代码"><a href="#九、代码" class="headerlink" title="九、代码"></a>九、代码</h1><p>语法：<br> 单行代码：代码之间分别用一个反引号包起来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;代码内容&#96;</span><br></pre></td></tr></table></figure>

<p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(&#96;&#96;&#96;)</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">(&#96;&#96;&#96;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。</p>
</blockquote>
<p>示例：</p>
<p>单行代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;create database hero;&#96;</span><br></pre></td></tr></table></figure>

<p>代码块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(&#96;&#96;&#96;)</span><br><span class="line">    function fun()&#123;</span><br><span class="line">         echo &quot;这是一句非常牛逼的代码&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    fun();</span><br><span class="line">(&#96;&#96;&#96;)</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p>单行代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database hero;</span><br></pre></td></tr></table></figure>

<p>代码块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fun()&#123;</span><br><span class="line">  echo &quot;这是一句非常牛逼的代码&quot;;</span><br><span class="line">&#125;</span><br><span class="line">fun();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>经验积累</category>
      </categories>
      <tags>
        <tag>MARKDOWN</tag>
      </tags>
  </entry>
  <entry>
    <title>给2020打个总结</title>
    <url>/2021/01/04/2021-first-blog/</url>
    <content><![CDATA[<h4 id="给2020打个总结"><a href="#给2020打个总结" class="headerlink" title="给2020打个总结"></a>给2020打个总结</h4><ul>
<li><p><input checked="" disabled="" type="checkbox">  健康度过2020</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  学习自己动手做了一个月菜</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  爬羊台山、梧桐山</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  给老爸换新车</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  给老妈买十字双开门大冰箱</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  学习购买基金进行投资</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  开了虾皮跨境店铺尝试开展副业</p>
</li>
</ul>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title>java Future模式</title>
    <url>/2021/01/27/java-Future%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>（本文收藏自博客园 作者：大诚挚）</p>
<p>先上一个场景：假如你突然想做饭，但是没有厨具，也没有食材。网上购买厨具比较方便，食材去超市买更放心。</p>
<p>实现分析：在快递员送厨具的期间，我们肯定不会闲着，可以去超市买食材。所以，在主线程里面另起一个子线程去网购厨具。</p>
<p>但是，子线程执行的结果是要返回厨具的，而run方法是没有返回值的。所以，这才是难点，需要好好考虑一下。<a id="more"></a></p>
<p>模拟代码1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package test;</span><br><span class="line"></span><br><span class="line">public class CommonCook &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">        &#x2F;&#x2F; 第一步 网购厨具</span><br><span class="line">        OnlineShopping thread &#x3D; new OnlineShopping();</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.join();  &#x2F;&#x2F; 保证厨具送到</span><br><span class="line">        &#x2F;&#x2F; 第二步 去超市购买食材</span><br><span class="line">        Thread.sleep(2000);  &#x2F;&#x2F; 模拟购买食材时间</span><br><span class="line">        Shicai shicai &#x3D; new Shicai();</span><br><span class="line">        System.out.println(&quot;第二步：食材到位&quot;);</span><br><span class="line">        &#x2F;&#x2F; 第三步 用厨具烹饪食材</span><br><span class="line">        System.out.println(&quot;第三步：开始展现厨艺&quot;);</span><br><span class="line">        cook(thread.chuju, shicai);</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;总共用时&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 网购厨具线程</span><br><span class="line">    static class OnlineShopping extends Thread &#123;</span><br><span class="line">        </span><br><span class="line">        private Chuju chuju;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;第一步：下单&quot;);</span><br><span class="line">            System.out.println(&quot;第一步：等待送货&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(5000);  &#x2F;&#x2F; 模拟送货时间</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;第一步：快递送到&quot;);</span><br><span class="line">            chuju &#x3D; new Chuju();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;  用厨具烹饪食材</span><br><span class="line">    static void cook(Chuju chuju, Shicai shicai) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 厨具类</span><br><span class="line">    static class Chuju &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 食材类</span><br><span class="line">    static class Shicai &#123;&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一步：下单</span><br><span class="line">第一步：等待送货</span><br><span class="line">第一步：快递送到</span><br><span class="line">第二步：食材到位</span><br><span class="line">第三步：开始展现厨艺</span><br><span class="line">总共用时7013ms</span><br></pre></td></tr></table></figure>

<p>可以看到，多线程已经失去了意义。在厨具送到期间，我们不能干任何事。对应代码，就是调用join方法阻塞主线程。</p>
<p>有人问了，不阻塞主线程行不行？？？</p>
<p>不行！！！</p>
<p>从代码来看的话，run方法不执行完，属性chuju就没有被赋值，还是null。换句话说，没有厨具，怎么做饭。</p>
<p>Java现在的多线程机制，核心方法run是没有返回值的；如果要保存run方法里面的计算结果，必须等待run方法计算完，无论计算过程多么耗时。</p>
<p>面对这种尴尬的处境，程序员就会想：在子线程run方法计算的期间，能不能在主线程里面继续异步执行？？？</p>
<p>Where there is a will，there is a way！！！</p>
<p>这种想法的核心就是Future模式，下面先应用一下Java自己实现的Future模式。</p>
<p>模拟代码2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package test;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.Callable;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line">public class FutureCook &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</span><br><span class="line">        long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">        &#x2F;&#x2F; 第一步 网购厨具</span><br><span class="line">        Callable&lt;Chuju&gt; onlineShopping &#x3D; new Callable&lt;Chuju&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public Chuju call() throws Exception &#123;</span><br><span class="line">                System.out.println(&quot;第一步：下单&quot;);</span><br><span class="line">                System.out.println(&quot;第一步：等待送货&quot;);</span><br><span class="line">                Thread.sleep(5000);  &#x2F;&#x2F; 模拟送货时间</span><br><span class="line">                System.out.println(&quot;第一步：快递送到&quot;);</span><br><span class="line">                return new Chuju();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;;</span><br><span class="line">        FutureTask&lt;Chuju&gt; task &#x3D; new FutureTask&lt;Chuju&gt;(onlineShopping);</span><br><span class="line">        new Thread(task).start();</span><br><span class="line">        &#x2F;&#x2F; 第二步 去超市购买食材</span><br><span class="line">        Thread.sleep(2000);  &#x2F;&#x2F; 模拟购买食材时间</span><br><span class="line">        Shicai shicai &#x3D; new Shicai();</span><br><span class="line">        System.out.println(&quot;第二步：食材到位&quot;);</span><br><span class="line">        &#x2F;&#x2F; 第三步 用厨具烹饪食材</span><br><span class="line">        if (!task.isDone()) &#123;  &#x2F;&#x2F; 联系快递员，询问是否到货</span><br><span class="line">            System.out.println(&quot;第三步：厨具还没到，心情好就等着（心情不好就调用cancel方法取消订单）&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Chuju chuju &#x3D; task.get();</span><br><span class="line">        System.out.println(&quot;第三步：厨具到位，开始展现厨艺&quot;);</span><br><span class="line">        cook(chuju, shicai);</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;总共用时&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;  用厨具烹饪食材</span><br><span class="line">    static void cook(Chuju chuju, Shicai shicai) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 厨具类</span><br><span class="line">    static class Chuju &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 食材类</span><br><span class="line">    static class Shicai &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一步：下单</span><br><span class="line">第一步：等待送货</span><br><span class="line">第二步：食材到位</span><br><span class="line">第三步：厨具还没到，心情好就等着（心情不好就调用cancel方法取消订单）</span><br><span class="line">第一步：快递送到</span><br><span class="line">第三步：厨具到位，开始展现厨艺</span><br><span class="line">总共用时5005ms</span><br></pre></td></tr></table></figure>



<p> 可以看见，在快递员送厨具的期间，我们没有闲着，可以去买食材；而且我们知道厨具到没到，甚至可以在厨具没到的时候，取消订单不要了。</p>
<p>好神奇，有没有。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>java中的逃逸分析</title>
    <url>/2021/02/01/java%E4%B8%AD%E7%9A%84%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>在Java的编译体系中，一个Java的源代码文件变成计算机可执行的机器指令的过程中，需要经过两段编译，第一段是把.java文件转换成.class文件。第二段编译是把.class转换成机器指令的过程。</p>
<p>第一段编译就是javac命令。</p>
<p>在第二编译阶段，JVM 通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。很显然，经过解释执行，其执行速度必然会比可执行的二进制字节码程序慢很多。这就是传统的JVM的解释器（Interpreter）的功能。为了解决这种效率问题，引入了 JIT（即时编译） 技术。</p>
<p>引入了 JIT 技术后，Java程序还是通过解释器进行解释执行，当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存起来，以备下次使用。</p>
<p>本文主要来介绍下JIT中的优化。JIT优化中最重要的一个就是逃逸分析。<a id="more"></a></p>
<h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p>关于逃逸分析的概念，可以参考对象并不一定都是在堆上分配内存的一文，这里简单回顾一下：</p>
<blockquote>
<p>逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。</p>
</blockquote>
<p>例如以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">craeteStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        sb.append(s1);</span><br><span class="line">        sb.append(s2);</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    	<span class="comment">//这里创建了一个StringBuffer对象，并且将它作为结果返回，允许其他方法调用，所以称为方法逃逸。（这里逃逸成功）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        sb.append(s1);</span><br><span class="line">        sb.append(s2);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">        <span class="comment">//这里也创建了一个StringBuffer对象，但是返回值却是String，所以没有逃逸成功</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>第一段代码中的sb就逃逸了，而第二段代码中的sb就没有逃逸。</p>
<p>使用逃逸分析，编译器可以对代码做如下优化：</p>
<p>一、同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p>
<p>二、将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。</p>
<p>三、分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</p>
<p>在Java代码运行时，通过JVM参数可指定是否开启逃逸分析，</p>
<p>-XX:+DoEscapeAnalysis ： 表示开启逃逸分析</p>
<p>-XX:-DoEscapeAnalysis ： 表示关闭逃逸分析 从jdk 1.7开始已经默认开始逃逸分析，如需关闭，需要指定-XX:-DoEscapeAnalysis</p>
<h4 id="同步省略"><a href="#同步省略" class="headerlink" title="同步省略"></a>同步省略</h4><p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。</p>
<p>如果同步块所使用的锁对象通过这种分析被证实只能够被一个线程访问，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这个取消同步的过程就叫同步省略，也叫锁消除。</p>
<p>如以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object hollis = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">synchronized</span>(hollis) &#123;</span><br><span class="line">            System.out.println(hollis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>代码中对hollis这个对象进行加锁，但是hollis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉。优化成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object hollis = <span class="keyword">new</span> Object();</span><br><span class="line">        System.out.println(hollis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>所以，在使用synchronized的时候，如果JIT经过逃逸分析之后发现并无线程安全问题的话，就会做锁消除。</p>
<h4 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h4><p>标量（Scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p>
<p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       alloc();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Point point = <span class="keyword">new</span> Point（<span class="number">1</span>,<span class="number">2</span>）;</span><br><span class="line">       System.out.println(<span class="string">&quot;point.x=&quot;</span>+point.x+<span class="string">&quot;; point.y=&quot;</span>+point.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以上代码中，point对象并没有逃逸出alloc方法，并且point对象是可以拆解成标量的。那么，JIT就会不会直接创建Point对象，而是直接使用两个标量int x ，int y来替代Point对象。</p>
<p>以上代码，经过标量替换后，就会变成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">      System.out.println(<span class="string">&quot;point.x=&quot;</span>+x+<span class="string">&quot;; point.y=&quot;</span>+y);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h6 id="可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。"><a href="#可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。" class="headerlink" title="可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。"></a>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。</h6><p>标量替换为栈上分配提供了很好的基础。</p>
<h4 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h4><p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。</p>
<p>关于栈上分配的详细介绍，可以参考对象并不一定都是在堆上分配内存的</p>
<p>这里，还是要简单说一下，其实在现有的虚拟机中，并没有真正的实现栈上分配，在对象并不一定都是在堆上分配内存的中我们的例子中，对象没有在堆上分配，其实是标量替换实现的。</p>
<p>逃逸分析并不成熟</p>
<p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK 1.6才有实现，而且这项技术到如今也并不是十分成熟的。</p>
<p>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</p>
<p>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p>
<p>虽然这项技术并不十分成熟，但是他也是即时编译器优化技术中一个十分重要的手段。</p>
<p>（转自CSDN<a href="https://blog.csdn.net/w372426096">Franco蜡笔小强</a>）</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>JVM,逃逸分析</tag>
      </tags>
  </entry>
  <entry>
    <title>netty学习第一天</title>
    <url>/2021/05/25/netty%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
    <content><![CDATA[<h2 id="Netty介绍"><a href="#Netty介绍" class="headerlink" title="Netty介绍"></a>Netty介绍</h2><p>netty：<strong>异步</strong>的、<strong>基于事件驱动</strong>的网络应用框架，用以快速开发高性能、高可靠性的网络IO程序；本质是一个NIO框架</p>
<p>使用场景：网络通讯中间件/框架（dubbo）、游戏、大数据</p>
<h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p>BIO（传统IO）：同步阻塞模型；适用于连接数较少且固定的架构，对服务器资源要求较高，并发局限于应用中，但程序简单易理解；客户端发起连接请求时服务端就需要启动一个线程进行处理，如果此线程不做任何事情，则会造成不必要的线程开销（可以通过线程池机制改善）</p>
<p>NIO：同步非阻塞模型；适用于连接数较多且连接比较短的架构，比如聊天服务器、弹幕系统、服务器间通信等，编程比较复杂；服务器实现模式为一个线程处理多个请求，即客户端请求注册到多路复用器上，多路复用器轮询，发现有IO请求的就进行处理</p>
<p>AIO：异步非阻塞模型；</p>
<h2 id="BIO-demo"><a href="#BIO-demo" class="headerlink" title="BIO demo"></a>BIO demo</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mes.eachen;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">//创建线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;正在阻塞中，等待客户端请求&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//监听、等待socket连接</span></span><br><span class="line">            <span class="keyword">final</span> Socket socket = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;有一个客户端已连接进入&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建一个线程，与之通讯</span></span><br><span class="line">            executorService.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//具体通讯逻辑</span></span><br><span class="line">                    handler(socket);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过socket获取输入流</span></span><br><span class="line">            InputStream in = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//循环读取客户端发来的数据</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;正在等待读取客户端信息&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> len = in.read(bytes);</span><br><span class="line">                <span class="keyword">if</span>(len != -<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//输出客户端发送的信息</span></span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;关闭和client的socket连接&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title>内部类在多线程中的应用</title>
    <url>/2021/02/01/%E5%86%85%E9%83%A8%E7%B1%BB%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>前两天做了个需求，需要用到多线程，并且需要在第一个线程跑完后，获取里边的一个字段来对其他线程使用，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SapPrsonTaskPro &#123;</span><br><span class="line">    private static Logger logger &#x3D; LoggerFactory.getLogger(SapPrsonTaskPro.class);</span><br><span class="line">    private int synCnt &#x3D; 10;</span><br><span class="line">    private boolean flag &#x3D; true;</span><br><span class="line">    @Autowired</span><br><span class="line">    private SapPersonService sapPersonService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private SapPersonMapper sapPersonMapper;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;@Scheduled(cron &#x3D; &quot;01 02 17 * * ? &quot;)</span><br><span class="line">    public void synSapPerson() throws InterruptedException &#123;</span><br><span class="line">        for(int i &#x3D; 1 ; i &lt;&#x3D; synCnt ; i++) &#123;</span><br><span class="line">            SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyyMMddHHmmss&quot;);</span><br><span class="line">            String currDate &#x3D; sdf.format(new Date());</span><br><span class="line">            logger.info(&quot;同步任务开始，时间为：&#123;&#125;&quot;,currDate);</span><br><span class="line">            &#x2F;&#x2F;全量的时候，public2为获取的次数，获取到的public4会有需要获取的总数</span><br><span class="line">            String I_Json &#x3D; &quot;&lt;I_JSON&gt;&#123;reqno:\&quot;1022&quot; + currDate + &quot;P0001\&quot;,type:\&quot;01\&quot;,public1:\&quot;\&quot;,public2:\&quot;&quot; + i + &quot;\&quot;,public3:\&quot;\&quot;&#125;&lt;&#x2F;I_JSON&gt;&quot;;</span><br><span class="line"></span><br><span class="line">            SyncPersonRunnable syncPersonRunnable &#x3D; new SyncPersonRunnable(I_Json,&quot;2&quot;);</span><br><span class="line"></span><br><span class="line">            Thread thread &#x3D; new Thread(syncPersonRunnable);</span><br><span class="line">            thread.setName(String.valueOf(i));</span><br><span class="line">            thread.start();</span><br><span class="line">            if(i &#x3D;&#x3D; 1)&#123;</span><br><span class="line">                ThreadGroup currentGroup &#x3D; Thread.currentThread().getThreadGroup();</span><br><span class="line"></span><br><span class="line">                int noThreads &#x3D; currentGroup.activeCount();</span><br><span class="line"></span><br><span class="line">                Thread[] lstThreads &#x3D; new Thread[noThreads];</span><br><span class="line"></span><br><span class="line">                currentGroup.enumerate(lstThreads);</span><br><span class="line"></span><br><span class="line">                for(int j &#x3D; 0; j &lt; lstThreads.length; j++)&#123;</span><br><span class="line">                    if(lstThreads[j].getName().equals(&quot;1&quot;))&#123;</span><br><span class="line">                        while(lstThreads[j].isAlive())&#123;</span><br><span class="line">                            Thread.sleep(3000);</span><br><span class="line">                            &#x2F;&#x2F;logger.info(&quot;正在等待线程&quot;+lstThreads[j].getName()+&quot;结束......&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class SyncPersonRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private String I_Json;</span><br><span class="line">        private String I_Type;</span><br><span class="line"></span><br><span class="line">        public SyncPersonRunnable(String I_Json, String I_Type) &#123;</span><br><span class="line">            this.I_Json &#x3D; I_Json;</span><br><span class="line">            this.I_Type &#x3D; I_Type;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            logger.info(&quot;线程：&quot;+Thread.currentThread().getName()+&quot;开启------------------------------&quot;);</span><br><span class="line">            List&lt;JSONObject&gt; objs &#x3D; new ArrayList&lt;JSONObject&gt;();</span><br><span class="line">            HttpClient client &#x3D; new HttpClient();</span><br><span class="line">            &#x2F;&#x2F; 设置连接超时</span><br><span class="line">            client.getHttpConnectionManager().getParams().setConnectionTimeout(100000);</span><br><span class="line">            &#x2F;&#x2F; 设置读取时间超时</span><br><span class="line">            client.getHttpConnectionManager().getParams().setSoTimeout(1000000);</span><br><span class="line"></span><br><span class="line">            PostMethod postMethod &#x3D; new PostMethod(&quot;。。。。。&quot;);</span><br><span class="line">            postMethod.setRequestHeader(&quot;Authorization&quot;,&quot;Basic dHJhbnNmZXI6MjAxNzEwMjU&#x3D;&quot;);</span><br><span class="line"></span><br><span class="line">            StringBuffer sb &#x3D; new StringBuffer();</span><br><span class="line">            sb.append(&quot;&lt;soapenv:Envelope xmlns:soapenv&#x3D;\&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;soap&#x2F;envelope&#x2F;\&quot; xmlns:urn&#x3D;\&quot;urn:sap-com:document:sap:rfc:functions\&quot;&gt;&quot;);</span><br><span class="line">            sb.append(&quot;&lt;soapenv:Header&#x2F;&gt;&quot;);</span><br><span class="line">            sb.append(&quot;&lt;soapenv:Body&gt;&quot;);</span><br><span class="line">            sb.append(&quot;&lt;urn:ZHRPA001&gt;&quot;);</span><br><span class="line">            sb.append(I_Json);</span><br><span class="line">            sb.append(&quot;&lt;&#x2F;urn:ZHRPA001&gt;&quot;);</span><br><span class="line">            sb.append(&quot;&lt;&#x2F;soapenv:Body&gt;&quot;);</span><br><span class="line">            sb.append(&quot;&lt;&#x2F;soapenv:Envelope&gt;&quot;);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                RequestEntity requestEntity &#x3D; new StringRequestEntity(sb.toString(), &quot;text&#x2F;xml&quot;, &quot;UTF-8&quot;);</span><br><span class="line">                postMethod.setRequestEntity(requestEntity);</span><br><span class="line">                int status &#x3D; client.executeMethod(postMethod);</span><br><span class="line">                if (status !&#x3D; 200) &#123;</span><br><span class="line">                    logger.info(&quot;同步SAP人员信息定时任务结束连接失败,失败段是: &#123;&#125;&quot;,I_Json);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                InputStream is &#x3D; postMethod.getResponseBodyAsStream();</span><br><span class="line">                &#x2F;&#x2F; 获取请求结果字符串</span><br><span class="line">                String result &#x3D; IOUtils.toString(is, &quot;UTF-8&quot;);</span><br><span class="line">                result &#x3D; result.replaceAll(&quot;\\\\&amp;&quot;, &quot;&amp;&quot;);</span><br><span class="line">                &#x2F;&#x2F;logger.info(result);</span><br><span class="line">                result &#x3D; result.substring(result.indexOf(&quot;&lt;E_JSON&gt;&quot;) + &quot;&lt;E_JSON&gt;&quot;.length(), result.indexOf(&quot;&lt;&#x2F;E_JSON&gt;&quot;));</span><br><span class="line">                List list &#x3D; JSON.parseObject(result, List.class);</span><br><span class="line"></span><br><span class="line">                if (list !&#x3D; null &amp;&amp; list.size() &gt; 0) &#123;</span><br><span class="line">                    for (int j &#x3D; 0; j &lt; list.size(); j++) &#123;</span><br><span class="line">                        JSONObject sap &#x3D; (JSONObject) list.get(j);</span><br><span class="line">                        if (flag &amp;&amp; sap.get(&quot;public4&quot;) !&#x3D; null &amp;&amp; StringUtils.isNotBlank(sap.get(&quot;public4&quot;).toString())) &#123;</span><br><span class="line">                            &#x2F;&#x2F;重新制定同步次数，因为每次同步只能获取1000条</span><br><span class="line">                            synCnt &#x3D; Integer.valueOf(sap.get(&quot;public4&quot;).toString().trim());</span><br><span class="line">                            logger.info(&quot;修改为：&quot;+synCnt);</span><br><span class="line">                            flag &#x3D; false;</span><br><span class="line">                        &#125;</span><br><span class="line">                        objs.add(sap);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;logger.info(&quot;第::&quot; + i + &quot;页,数据获取完毕，开始插入数据库&quot;);</span><br><span class="line">                SapPrsonTaskPro.this.sapPersonService.saveSapPersonList(objs);</span><br><span class="line">                logger.info(&quot;线程&quot;+Thread.currentThread().getName()+&quot;已同步完成&quot;);</span><br><span class="line">            &#125;catch (Exception e)&#123;</span><br><span class="line">                logger.error(&quot;同步SAP人员信息任务异常&quot;,e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>一个莫名其妙的报错</title>
    <url>/2021/02/25/%E4%B8%80%E4%B8%AA%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E7%9A%84%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>今天在原有的代码上加了个方法，噼里啪啦一顿操作写完，一运行，报错了 emmmmm</p>
<p><img src="https://raw.githubusercontent.com/eachen6/blogImgBed/main/20210225164058.png" alt="image-20210225164057946"></p>
<p>代码如下：</p>
<p><img src="https://raw.githubusercontent.com/eachen6/blogImgBed/main/20210225163805.png" alt="image-20210225163805383"></p>
<blockquote>
<p>稍等 让我找找原因先</p>
</blockquote>
]]></content>
  </entry>
</search>
