<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ORACLE周函数</title>
    <url>/2020/12/16/ORACLE%E5%91%A8%E5%87%BD%E6%95%B0-0/</url>
    <content><![CDATA[<p>工作中经常需要做一些报表数据的统计，其中就包括以周为单位的统计，这里对oracle的相关周函数进行记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select</span><br><span class="line">       to_char(sysdate,&#39;W&#39;), --当天是当月是第几周</span><br><span class="line">       to_char(sysdate,&#39;WW&#39;), --每年1月1日时第一周第一天开始算,当前时间是当年第几周</span><br><span class="line">       to_char(sysdate,&#39;IW&#39;)  --当前时间是当年第几周（自然周）</span><br><span class="line"> from dual;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>经验积累</category>
      </categories>
      <tags>
        <tag>ORACLE</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown学习内容</title>
    <url>/2020/12/11/first-blog/</url>
    <content><![CDATA[<p>Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>
<p>相比WYSIWYG编辑器</p>
<p><strong>优点：</strong><br> 1、因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。<br> 2、操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可</p>
<p><strong>缺点：</strong><br> 1、需要记一些语法（当然，是很简单。五分钟学会）。<br> 2、有些平台不支持Markdown编辑模式。</p>
<p>还好，简书是支持Markdown编辑模式的。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开启方式：设置-&gt;默认编辑器-&gt;Markdown编辑器</span><br></pre></td></tr></table></figure>

<h1 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h1><p>在想要设置为标题的文字前面加#来表示<br> 一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。</p>
<p>注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><hr>
<h1 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h1><ul>
<li><h5 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h5></li>
</ul>
<p>要加粗的文字左右分别用两个*号包起来</p>
<ul>
<li><h5 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h5></li>
</ul>
<p>要倾斜的文字左右分别用一个*号包起来</p>
<ul>
<li><h5 id="斜体加粗"><a href="#斜体加粗" class="headerlink" title="斜体加粗"></a>斜体加粗</h5></li>
</ul>
<p>要倾斜和加粗的文字左右分别用三个*号包起来</p>
<ul>
<li><h5 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h5></li>
</ul>
<p>要加删除线的文字左右分别用两个~~号包起来</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*&#96;</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><strong>这是加粗的文字</strong><br> <em>这是倾斜的文字</em><br> <strong><em>这是斜体加粗的文字\</em></strong><br> <del>这是加删除线的文字</del></p>
<hr>
<h1 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h1><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;<br> n个…<br> 貌似可以一直加下去，但没神马卵用</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
<h1 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h1><p>三个或者三个以上的 - 或者 * 都可以。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure>

<p>效果如下：<br> 可以看到，显示效果是一样的。</p>
<hr>
<hr>
<hr>
<hr>
<h1 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h1><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![blockchain](https:&#x2F;&#x2F;ss0.bdstatic.com&#x2F;70cFvHSh_Q1YnxGkpoWK1HF6hhy&#x2F;it&#x2F;</span><br><span class="line">u&#x3D;702257389,1274025419&amp;fm&#x3D;27&amp;gp&#x3D;0.jpg &quot;区块链&quot;)</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6860761-fd2f51090a890873.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/550/format/webp" alt="img"></p>
<p>blockchain</p>
<p><strong>上传本地图片直接点击导航栏的图片标志，选择图片即可</strong></p>
<p>markdown格式追求的是简单、多平台统一。那么图片的存储就是一个问题，需要用图床，提供统一的外链，这样就不用在不同的平台去处理图片的问题了。才能做到书写一次，各处使用。<br> 关于图床的选择我写了一篇文章，对网上存在的各种方法做了总结，需要的朋友可以看看。<a href="https://www.jianshu.com/p/ea1eb11db63f">markdown图床</a></p>
<h1 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h1><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">title可加可不加</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[简书](http:&#x2F;&#x2F;jianshu.com)</span><br><span class="line">[百度](http:&#x2F;&#x2F;baidu.com)</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><a href="https://www.jianshu.com/u/1f5ac0cf6a8b">简书</a><br> <a href="https://links.jianshu.com/go?to=http://baidu.com">百度</a></p>
<p>注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;超链接地址&quot; target&#x3D;&quot;_blank&quot;&gt;超链接名&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">示例</span><br><span class="line">&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;1f5ac0cf6a8b&quot; target&#x3D;&quot;_blank&quot;&gt;简书&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h1><h5 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h5><p>语法：<br> 无序列表用 - + * 任何一种都可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line"></span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<ul>
<li>列表内容</li>
<li>列表内容</li>
<li>列表内容</li>
</ul>
<h5 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h5><p>语法：<br> 数字加点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 列表内容</span><br><span class="line">2. 列表内容</span><br><span class="line">3. 列表内容</span><br><span class="line"></span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<ol>
<li>列表内容</li>
<li>列表内容</li>
<li>列表内容</li>
</ol>
<h5 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h5><p><strong>上一级和下一级之间敲三个空格即可</strong></p>
<ul>
<li>一级无序列表内容<ul>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
</ul>
</li>
<li>一级无序列表内容<ol>
<li>二级有序列表内容</li>
<li>二级有序列表内容</li>
<li>二级有序列表内容</li>
</ol>
</li>
</ul>
<ol>
<li>一级有序列表内容<ul>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
</ul>
</li>
<li>一级有序列表内容<ol>
<li>二级有序列表内容</li>
<li>二级有序列表内容</li>
<li>二级有序列表内容</li>
</ol>
</li>
</ol>
<hr>
<h1 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h1><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line">- 有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br><span class="line">注：原生的语法两边都要用 | 包起来。此处省略</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">姓名|技能|排行</span><br><span class="line">--|:--:|--:</span><br><span class="line">刘备|哭|大哥</span><br><span class="line">关羽|打|二哥</span><br><span class="line">张飞|骂|三弟</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<table>
<thead>
<tr>
<th>姓名</th>
<th align="center">技能</th>
<th align="right">排行</th>
</tr>
</thead>
<tbody><tr>
<td>刘备</td>
<td align="center">哭</td>
<td align="right">大哥</td>
</tr>
<tr>
<td>关羽</td>
<td align="center">打</td>
<td align="right">二哥</td>
</tr>
<tr>
<td>张飞</td>
<td align="center">骂</td>
<td align="right">三弟</td>
</tr>
</tbody></table>
<h1 id="九、代码"><a href="#九、代码" class="headerlink" title="九、代码"></a>九、代码</h1><p>语法：<br> 单行代码：代码之间分别用一个反引号包起来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;代码内容&#96;</span><br></pre></td></tr></table></figure>

<p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(&#96;&#96;&#96;)</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">(&#96;&#96;&#96;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。</p>
</blockquote>
<p>示例：</p>
<p>单行代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;create database hero;&#96;</span><br></pre></td></tr></table></figure>

<p>代码块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(&#96;&#96;&#96;)</span><br><span class="line">    function fun()&#123;</span><br><span class="line">         echo &quot;这是一句非常牛逼的代码&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    fun();</span><br><span class="line">(&#96;&#96;&#96;)</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p>单行代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database hero;</span><br></pre></td></tr></table></figure>

<p>代码块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fun()&#123;</span><br><span class="line">  echo &quot;这是一句非常牛逼的代码&quot;;</span><br><span class="line">&#125;</span><br><span class="line">fun();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>经验积累</category>
      </categories>
      <tags>
        <tag>MARKDOWN</tag>
      </tags>
  </entry>
  <entry>
    <title>给2020打个总结</title>
    <url>/2021/01/04/2021-first-blog/</url>
    <content><![CDATA[<h4 id="给2020打个总结"><a href="#给2020打个总结" class="headerlink" title="给2020打个总结"></a>给2020打个总结</h4><ul>
<li><p><input checked="" disabled="" type="checkbox">  健康度过2020</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  学习自己动手做了一个月菜</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  爬羊台山、梧桐山</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  给老爸换新车</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  给老妈买十字双开门大冰箱</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  学习购买基金进行投资</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  开了虾皮跨境店铺尝试开展副业</p>
</li>
</ul>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title>java Future模式</title>
    <url>/2021/01/27/java-Future%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>（本文收藏自博客园 作者：大诚挚）</p>
<p>先上一个场景：假如你突然想做饭，但是没有厨具，也没有食材。网上购买厨具比较方便，食材去超市买更放心。</p>
<p>实现分析：在快递员送厨具的期间，我们肯定不会闲着，可以去超市买食材。所以，在主线程里面另起一个子线程去网购厨具。</p>
<p>但是，子线程执行的结果是要返回厨具的，而run方法是没有返回值的。所以，这才是难点，需要好好考虑一下。<a id="more"></a></p>
<p>模拟代码1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package test;</span><br><span class="line"></span><br><span class="line">public class CommonCook &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">        &#x2F;&#x2F; 第一步 网购厨具</span><br><span class="line">        OnlineShopping thread &#x3D; new OnlineShopping();</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.join();  &#x2F;&#x2F; 保证厨具送到</span><br><span class="line">        &#x2F;&#x2F; 第二步 去超市购买食材</span><br><span class="line">        Thread.sleep(2000);  &#x2F;&#x2F; 模拟购买食材时间</span><br><span class="line">        Shicai shicai &#x3D; new Shicai();</span><br><span class="line">        System.out.println(&quot;第二步：食材到位&quot;);</span><br><span class="line">        &#x2F;&#x2F; 第三步 用厨具烹饪食材</span><br><span class="line">        System.out.println(&quot;第三步：开始展现厨艺&quot;);</span><br><span class="line">        cook(thread.chuju, shicai);</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;总共用时&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 网购厨具线程</span><br><span class="line">    static class OnlineShopping extends Thread &#123;</span><br><span class="line">        </span><br><span class="line">        private Chuju chuju;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;第一步：下单&quot;);</span><br><span class="line">            System.out.println(&quot;第一步：等待送货&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(5000);  &#x2F;&#x2F; 模拟送货时间</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;第一步：快递送到&quot;);</span><br><span class="line">            chuju &#x3D; new Chuju();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;  用厨具烹饪食材</span><br><span class="line">    static void cook(Chuju chuju, Shicai shicai) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 厨具类</span><br><span class="line">    static class Chuju &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 食材类</span><br><span class="line">    static class Shicai &#123;&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一步：下单</span><br><span class="line">第一步：等待送货</span><br><span class="line">第一步：快递送到</span><br><span class="line">第二步：食材到位</span><br><span class="line">第三步：开始展现厨艺</span><br><span class="line">总共用时7013ms</span><br></pre></td></tr></table></figure>

<p>可以看到，多线程已经失去了意义。在厨具送到期间，我们不能干任何事。对应代码，就是调用join方法阻塞主线程。</p>
<p>有人问了，不阻塞主线程行不行？？？</p>
<p>不行！！！</p>
<p>从代码来看的话，run方法不执行完，属性chuju就没有被赋值，还是null。换句话说，没有厨具，怎么做饭。</p>
<p>Java现在的多线程机制，核心方法run是没有返回值的；如果要保存run方法里面的计算结果，必须等待run方法计算完，无论计算过程多么耗时。</p>
<p>面对这种尴尬的处境，程序员就会想：在子线程run方法计算的期间，能不能在主线程里面继续异步执行？？？</p>
<p>Where there is a will，there is a way！！！</p>
<p>这种想法的核心就是Future模式，下面先应用一下Java自己实现的Future模式。</p>
<p>模拟代码2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package test;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.Callable;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line">public class FutureCook &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</span><br><span class="line">        long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">        &#x2F;&#x2F; 第一步 网购厨具</span><br><span class="line">        Callable&lt;Chuju&gt; onlineShopping &#x3D; new Callable&lt;Chuju&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public Chuju call() throws Exception &#123;</span><br><span class="line">                System.out.println(&quot;第一步：下单&quot;);</span><br><span class="line">                System.out.println(&quot;第一步：等待送货&quot;);</span><br><span class="line">                Thread.sleep(5000);  &#x2F;&#x2F; 模拟送货时间</span><br><span class="line">                System.out.println(&quot;第一步：快递送到&quot;);</span><br><span class="line">                return new Chuju();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;;</span><br><span class="line">        FutureTask&lt;Chuju&gt; task &#x3D; new FutureTask&lt;Chuju&gt;(onlineShopping);</span><br><span class="line">        new Thread(task).start();</span><br><span class="line">        &#x2F;&#x2F; 第二步 去超市购买食材</span><br><span class="line">        Thread.sleep(2000);  &#x2F;&#x2F; 模拟购买食材时间</span><br><span class="line">        Shicai shicai &#x3D; new Shicai();</span><br><span class="line">        System.out.println(&quot;第二步：食材到位&quot;);</span><br><span class="line">        &#x2F;&#x2F; 第三步 用厨具烹饪食材</span><br><span class="line">        if (!task.isDone()) &#123;  &#x2F;&#x2F; 联系快递员，询问是否到货</span><br><span class="line">            System.out.println(&quot;第三步：厨具还没到，心情好就等着（心情不好就调用cancel方法取消订单）&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Chuju chuju &#x3D; task.get();</span><br><span class="line">        System.out.println(&quot;第三步：厨具到位，开始展现厨艺&quot;);</span><br><span class="line">        cook(chuju, shicai);</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;总共用时&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;  用厨具烹饪食材</span><br><span class="line">    static void cook(Chuju chuju, Shicai shicai) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 厨具类</span><br><span class="line">    static class Chuju &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 食材类</span><br><span class="line">    static class Shicai &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一步：下单</span><br><span class="line">第一步：等待送货</span><br><span class="line">第二步：食材到位</span><br><span class="line">第三步：厨具还没到，心情好就等着（心情不好就调用cancel方法取消订单）</span><br><span class="line">第一步：快递送到</span><br><span class="line">第三步：厨具到位，开始展现厨艺</span><br><span class="line">总共用时5005ms</span><br></pre></td></tr></table></figure>



<p> 可以看见，在快递员送厨具的期间，我们没有闲着，可以去买食材；而且我们知道厨具到没到，甚至可以在厨具没到的时候，取消订单不要了。</p>
<p>好神奇，有没有。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>java中的逃逸分析</title>
    <url>/2021/02/01/java%E4%B8%AD%E7%9A%84%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>在Java的编译体系中，一个Java的源代码文件变成计算机可执行的机器指令的过程中，需要经过两段编译，第一段是把.java文件转换成.class文件。第二段编译是把.class转换成机器指令的过程。</p>
<p>第一段编译就是javac命令。</p>
<p>在第二编译阶段，JVM 通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。很显然，经过解释执行，其执行速度必然会比可执行的二进制字节码程序慢很多。这就是传统的JVM的解释器（Interpreter）的功能。为了解决这种效率问题，引入了 JIT（即时编译） 技术。</p>
<p>引入了 JIT 技术后，Java程序还是通过解释器进行解释执行，当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存起来，以备下次使用。</p>
<p>本文主要来介绍下JIT中的优化。JIT优化中最重要的一个就是逃逸分析。<a id="more"></a></p>
<h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p>关于逃逸分析的概念，可以参考对象并不一定都是在堆上分配内存的一文，这里简单回顾一下：</p>
<blockquote>
<p>逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。</p>
</blockquote>
<p>例如以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">craeteStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        sb.append(s1);</span><br><span class="line">        sb.append(s2);</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    	<span class="comment">//这里创建了一个StringBuffer对象，并且将它作为结果返回，允许其他方法调用，所以称为方法逃逸。（这里逃逸成功）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        sb.append(s1);</span><br><span class="line">        sb.append(s2);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">        <span class="comment">//这里也创建了一个StringBuffer对象，但是返回值却是String，所以没有逃逸成功</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>第一段代码中的sb就逃逸了，而第二段代码中的sb就没有逃逸。</p>
<p>使用逃逸分析，编译器可以对代码做如下优化：</p>
<p>一、同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p>
<p>二、将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。</p>
<p>三、分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</p>
<p>在Java代码运行时，通过JVM参数可指定是否开启逃逸分析，</p>
<p>-XX:+DoEscapeAnalysis ： 表示开启逃逸分析</p>
<p>-XX:-DoEscapeAnalysis ： 表示关闭逃逸分析 从jdk 1.7开始已经默认开始逃逸分析，如需关闭，需要指定-XX:-DoEscapeAnalysis</p>
<h4 id="同步省略"><a href="#同步省略" class="headerlink" title="同步省略"></a>同步省略</h4><p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。</p>
<p>如果同步块所使用的锁对象通过这种分析被证实只能够被一个线程访问，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这个取消同步的过程就叫同步省略，也叫锁消除。</p>
<p>如以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object hollis = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">synchronized</span>(hollis) &#123;</span><br><span class="line">            System.out.println(hollis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>代码中对hollis这个对象进行加锁，但是hollis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉。优化成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object hollis = <span class="keyword">new</span> Object();</span><br><span class="line">        System.out.println(hollis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>所以，在使用synchronized的时候，如果JIT经过逃逸分析之后发现并无线程安全问题的话，就会做锁消除。</p>
<h4 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h4><p>标量（Scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p>
<p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       alloc();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Point point = <span class="keyword">new</span> Point（<span class="number">1</span>,<span class="number">2</span>）;</span><br><span class="line">       System.out.println(<span class="string">&quot;point.x=&quot;</span>+point.x+<span class="string">&quot;; point.y=&quot;</span>+point.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以上代码中，point对象并没有逃逸出alloc方法，并且point对象是可以拆解成标量的。那么，JIT就会不会直接创建Point对象，而是直接使用两个标量int x ，int y来替代Point对象。</p>
<p>以上代码，经过标量替换后，就会变成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">      System.out.println(<span class="string">&quot;point.x=&quot;</span>+x+<span class="string">&quot;; point.y=&quot;</span>+y);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h6 id="可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。"><a href="#可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。" class="headerlink" title="可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。"></a>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。</h6><p>标量替换为栈上分配提供了很好的基础。</p>
<h4 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h4><p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。</p>
<p>关于栈上分配的详细介绍，可以参考对象并不一定都是在堆上分配内存的</p>
<p>这里，还是要简单说一下，其实在现有的虚拟机中，并没有真正的实现栈上分配，在对象并不一定都是在堆上分配内存的中我们的例子中，对象没有在堆上分配，其实是标量替换实现的。</p>
<p>逃逸分析并不成熟</p>
<p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK 1.6才有实现，而且这项技术到如今也并不是十分成熟的。</p>
<p>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</p>
<p>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p>
<p>虽然这项技术并不十分成熟，但是他也是即时编译器优化技术中一个十分重要的手段。</p>
<p>（转自CSDN<a href="https://blog.csdn.net/w372426096">Franco蜡笔小强</a>）</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>JVM,逃逸分析</tag>
      </tags>
  </entry>
  <entry>
    <title>netty学习第一天</title>
    <url>/2021/05/25/netty%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
    <content><![CDATA[<h2 id="Netty介绍"><a href="#Netty介绍" class="headerlink" title="Netty介绍"></a>Netty介绍</h2><p>netty：<strong>异步</strong>的、<strong>基于事件驱动</strong>的网络应用框架，用以快速开发高性能、高可靠性的网络IO程序；本质是一个NIO框架</p>
<p>使用场景：网络通讯中间件/框架（dubbo）、游戏、大数据</p>
<h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p>BIO（传统IO）：同步阻塞模型；适用于连接数较少且固定的架构，对服务器资源要求较高，并发局限于应用中，但程序简单易理解；客户端发起连接请求时服务端就需要启动一个线程进行处理，如果此线程不做任何事情，则会造成不必要的线程开销（可以通过线程池机制改善）</p>
<p>NIO：同步非阻塞模型；适用于连接数较多且连接比较短的架构，比如聊天服务器、弹幕系统、服务器间通信等，编程比较复杂；服务器实现模式为一个线程处理多个请求，即客户端请求注册到多路复用器上，多路复用器轮询，发现有IO请求的就进行处理</p>
<p>AIO：异步非阻塞模型；<a id="more"></a></p>
<h2 id="BIO-demo"><a href="#BIO-demo" class="headerlink" title="BIO demo"></a>BIO demo</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mes.eachen;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">//创建线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;正在阻塞中，等待客户端请求&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//监听、等待socket连接</span></span><br><span class="line">            <span class="keyword">final</span> Socket socket = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;有一个客户端已连接进入&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建一个线程，与之通讯</span></span><br><span class="line">            executorService.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//具体通讯逻辑</span></span><br><span class="line">                    handler(socket);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过socket获取输入流</span></span><br><span class="line">            InputStream in = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//循环读取客户端发来的数据</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;正在等待读取客户端信息&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> len = in.read(bytes);</span><br><span class="line">                <span class="keyword">if</span>(len != -<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//输出客户端发送的信息</span></span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;关闭和client的socket连接&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title>内部类在多线程中的应用</title>
    <url>/2021/02/01/%E5%86%85%E9%83%A8%E7%B1%BB%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>前两天做了个需求，需要用到多线程，并且需要在第一个线程跑完后，获取里边的一个字段来对其他线程使用，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SapPrsonTaskPro &#123;</span><br><span class="line">    private static Logger logger &#x3D; LoggerFactory.getLogger(SapPrsonTaskPro.class);</span><br><span class="line">    private int synCnt &#x3D; 10;</span><br><span class="line">    private boolean flag &#x3D; true;</span><br><span class="line">    @Autowired</span><br><span class="line">    private SapPersonService sapPersonService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private SapPersonMapper sapPersonMapper;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;@Scheduled(cron &#x3D; &quot;01 02 17 * * ? &quot;)</span><br><span class="line">    public void synSapPerson() throws InterruptedException &#123;</span><br><span class="line">        for(int i &#x3D; 1 ; i &lt;&#x3D; synCnt ; i++) &#123;</span><br><span class="line">            SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyyMMddHHmmss&quot;);</span><br><span class="line">            String currDate &#x3D; sdf.format(new Date());</span><br><span class="line">            logger.info(&quot;同步任务开始，时间为：&#123;&#125;&quot;,currDate);</span><br><span class="line">            &#x2F;&#x2F;全量的时候，public2为获取的次数，获取到的public4会有需要获取的总数</span><br><span class="line">            String I_Json &#x3D; &quot;&lt;I_JSON&gt;&#123;reqno:\&quot;1022&quot; + currDate + &quot;P0001\&quot;,type:\&quot;01\&quot;,public1:\&quot;\&quot;,public2:\&quot;&quot; + i + &quot;\&quot;,public3:\&quot;\&quot;&#125;&lt;&#x2F;I_JSON&gt;&quot;;</span><br><span class="line"></span><br><span class="line">            SyncPersonRunnable syncPersonRunnable &#x3D; new SyncPersonRunnable(I_Json,&quot;2&quot;);</span><br><span class="line"></span><br><span class="line">            Thread thread &#x3D; new Thread(syncPersonRunnable);</span><br><span class="line">            thread.setName(String.valueOf(i));</span><br><span class="line">            thread.start();</span><br><span class="line">            if(i &#x3D;&#x3D; 1)&#123;</span><br><span class="line">                ThreadGroup currentGroup &#x3D; Thread.currentThread().getThreadGroup();</span><br><span class="line"></span><br><span class="line">                int noThreads &#x3D; currentGroup.activeCount();</span><br><span class="line"></span><br><span class="line">                Thread[] lstThreads &#x3D; new Thread[noThreads];</span><br><span class="line"></span><br><span class="line">                currentGroup.enumerate(lstThreads);</span><br><span class="line"></span><br><span class="line">                for(int j &#x3D; 0; j &lt; lstThreads.length; j++)&#123;</span><br><span class="line">                    if(lstThreads[j].getName().equals(&quot;1&quot;))&#123;</span><br><span class="line">                        while(lstThreads[j].isAlive())&#123;</span><br><span class="line">                            Thread.sleep(3000);</span><br><span class="line">                            &#x2F;&#x2F;logger.info(&quot;正在等待线程&quot;+lstThreads[j].getName()+&quot;结束......&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class SyncPersonRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private String I_Json;</span><br><span class="line">        private String I_Type;</span><br><span class="line"></span><br><span class="line">        public SyncPersonRunnable(String I_Json, String I_Type) &#123;</span><br><span class="line">            this.I_Json &#x3D; I_Json;</span><br><span class="line">            this.I_Type &#x3D; I_Type;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            logger.info(&quot;线程：&quot;+Thread.currentThread().getName()+&quot;开启------------------------------&quot;);</span><br><span class="line">            List&lt;JSONObject&gt; objs &#x3D; new ArrayList&lt;JSONObject&gt;();</span><br><span class="line">            HttpClient client &#x3D; new HttpClient();</span><br><span class="line">            &#x2F;&#x2F; 设置连接超时</span><br><span class="line">            client.getHttpConnectionManager().getParams().setConnectionTimeout(100000);</span><br><span class="line">            &#x2F;&#x2F; 设置读取时间超时</span><br><span class="line">            client.getHttpConnectionManager().getParams().setSoTimeout(1000000);</span><br><span class="line"></span><br><span class="line">            PostMethod postMethod &#x3D; new PostMethod(&quot;。。。。。&quot;);</span><br><span class="line">            postMethod.setRequestHeader(&quot;Authorization&quot;,&quot;Basic dHJhbnNmZXI6MjAxNzEwMjU&#x3D;&quot;);</span><br><span class="line"></span><br><span class="line">            StringBuffer sb &#x3D; new StringBuffer();</span><br><span class="line">            sb.append(&quot;&lt;soapenv:Envelope xmlns:soapenv&#x3D;\&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;soap&#x2F;envelope&#x2F;\&quot; xmlns:urn&#x3D;\&quot;urn:sap-com:document:sap:rfc:functions\&quot;&gt;&quot;);</span><br><span class="line">            sb.append(&quot;&lt;soapenv:Header&#x2F;&gt;&quot;);</span><br><span class="line">            sb.append(&quot;&lt;soapenv:Body&gt;&quot;);</span><br><span class="line">            sb.append(&quot;&lt;urn:ZHRPA001&gt;&quot;);</span><br><span class="line">            sb.append(I_Json);</span><br><span class="line">            sb.append(&quot;&lt;&#x2F;urn:ZHRPA001&gt;&quot;);</span><br><span class="line">            sb.append(&quot;&lt;&#x2F;soapenv:Body&gt;&quot;);</span><br><span class="line">            sb.append(&quot;&lt;&#x2F;soapenv:Envelope&gt;&quot;);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                RequestEntity requestEntity &#x3D; new StringRequestEntity(sb.toString(), &quot;text&#x2F;xml&quot;, &quot;UTF-8&quot;);</span><br><span class="line">                postMethod.setRequestEntity(requestEntity);</span><br><span class="line">                int status &#x3D; client.executeMethod(postMethod);</span><br><span class="line">                if (status !&#x3D; 200) &#123;</span><br><span class="line">                    logger.info(&quot;同步SAP人员信息定时任务结束连接失败,失败段是: &#123;&#125;&quot;,I_Json);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                InputStream is &#x3D; postMethod.getResponseBodyAsStream();</span><br><span class="line">                &#x2F;&#x2F; 获取请求结果字符串</span><br><span class="line">                String result &#x3D; IOUtils.toString(is, &quot;UTF-8&quot;);</span><br><span class="line">                result &#x3D; result.replaceAll(&quot;\\\\&amp;&quot;, &quot;&amp;&quot;);</span><br><span class="line">                &#x2F;&#x2F;logger.info(result);</span><br><span class="line">                result &#x3D; result.substring(result.indexOf(&quot;&lt;E_JSON&gt;&quot;) + &quot;&lt;E_JSON&gt;&quot;.length(), result.indexOf(&quot;&lt;&#x2F;E_JSON&gt;&quot;));</span><br><span class="line">                List list &#x3D; JSON.parseObject(result, List.class);</span><br><span class="line"></span><br><span class="line">                if (list !&#x3D; null &amp;&amp; list.size() &gt; 0) &#123;</span><br><span class="line">                    for (int j &#x3D; 0; j &lt; list.size(); j++) &#123;</span><br><span class="line">                        JSONObject sap &#x3D; (JSONObject) list.get(j);</span><br><span class="line">                        if (flag &amp;&amp; sap.get(&quot;public4&quot;) !&#x3D; null &amp;&amp; StringUtils.isNotBlank(sap.get(&quot;public4&quot;).toString())) &#123;</span><br><span class="line">                            &#x2F;&#x2F;重新制定同步次数，因为每次同步只能获取1000条</span><br><span class="line">                            synCnt &#x3D; Integer.valueOf(sap.get(&quot;public4&quot;).toString().trim());</span><br><span class="line">                            logger.info(&quot;修改为：&quot;+synCnt);</span><br><span class="line">                            flag &#x3D; false;</span><br><span class="line">                        &#125;</span><br><span class="line">                        objs.add(sap);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;logger.info(&quot;第::&quot; + i + &quot;页,数据获取完毕，开始插入数据库&quot;);</span><br><span class="line">                SapPrsonTaskPro.this.sapPersonService.saveSapPersonList(objs);</span><br><span class="line">                logger.info(&quot;线程&quot;+Thread.currentThread().getName()+&quot;已同步完成&quot;);</span><br><span class="line">            &#125;catch (Exception e)&#123;</span><br><span class="line">                logger.error(&quot;同步SAP人员信息任务异常&quot;,e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工作经验</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>一个莫名其妙的报错</title>
    <url>/2021/02/25/%E4%B8%80%E4%B8%AA%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E7%9A%84%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>今天在原有的代码上加了个方法，噼里啪啦一顿操作写完，一运行，报错了 emmmmm</p>
<p><img src="https://raw.githubusercontent.com/eachen6/blogImgBed/main/20210225164058.png" alt="image-20210225164057946"></p>
<p>代码如下：</p>
<p><img src="https://raw.githubusercontent.com/eachen6/blogImgBed/main/20210225163805.png" alt="image-20210225163805383"></p>
<blockquote>
<p>稍等 让我找找原因先</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>netty学习第二天</title>
    <url>/2021/05/26/netty%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%A4%A9/</url>
    <content><![CDATA[<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>NIO是面向缓冲区编程的一种非阻塞IO</p>
<ul>
<li>selector（选择器）</li>
<li>buffer（缓冲区）</li>
<li>channel（通道）</li>
</ul>
<p>一个selector对应一个线程</p>
<p>一个buffer对应一个channel</p>
<p>一个selector对应多个channel</p>
<p>buffer和channel的读写都是双向的</p>
<h3 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h3><p>最重要的四个属性：mark、position、limit、capacity</p>
<p>读写切换的方法：flip()</p>
<h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>常用的有：FileChannel、ServerSocketChannel（TCP）、SocketChannel（TCP）、DatagramChannel（UDP）<a id="more"></a></p>
<p>一个使用FileChannel的文件写操作的demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIO</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//这是要写进文件的内容</span></span><br><span class="line">        String s = <span class="string">&quot;Hello? 怎么还不下班&quot;</span>;</span><br><span class="line">        <span class="comment">//创建文件输出流</span></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;f:\\testNIO20210526.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//根据文件输出流获取通道</span></span><br><span class="line">        FileChannel fileChannel = fileOutputStream.getChannel();</span><br><span class="line">        <span class="comment">//创建Buffer缓冲区</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">//将内容写进字节缓冲区</span></span><br><span class="line">        byteBuffer.put(s.getBytes());</span><br><span class="line">        <span class="comment">//将buffer切换为读模式</span></span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        <span class="comment">//将buffer的数据写进通道中</span></span><br><span class="line">        fileChannel.write(byteBuffer);</span><br><span class="line">        <span class="comment">//将文件输出流关闭</span></span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/eachen6/blogImgBed/main/20210526210915.png" alt="image-20210526210914046"></p>
<h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>写了一晚的笔记，写完demo后被我误删了，这个是精简后补上的（枯）！</p>
<p>今天先到这，明天继续</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA IO 相关内容</title>
    <url>/2021/05/26/JAVA-IO-%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<h2 id="一、概览"><a href="#一、概览" class="headerlink" title="一、概览"></a>一、概览</h2><p>Java的IO大概可以分为以下几类：</p>
<ul>
<li>磁盘操作：File</li>
<li>字节操作：InputStream和OutPutStream</li>
<li>字符操作：Reader和Writer</li>
<li>对象操作：Serializable</li>
<li>网络操作：Socket</li>
<li>新的IO：NIO</li>
</ul>
<h2 id="二、磁盘操作"><a href="#二、磁盘操作" class="headerlink" title="二、磁盘操作"></a>二、磁盘操作</h2><p>File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。</p>
<p>递归地列出一个目录下所有文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listAllFiles</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="keyword">null</span> || !dir.exists()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dir.isFile()) &#123;</span><br><span class="line">        System.out.println(dir.getName());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (File file : dir.listFiles()) &#123;</span><br><span class="line">        listAllFiles(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 Java7 开始，可以使用 Paths 和 Files 代替 File。（有机会再细看这两者）<a id="more"></a></p>
<h2 id="三、字节操作"><a href="#三、字节操作" class="headerlink" title="三、字节操作"></a>三、字节操作</h2><h3 id="实现文件复制"><a href="#实现文件复制" class="headerlink" title="实现文件复制"></a>实现文件复制</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(String src, String dist)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileInputStream in = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">    FileOutputStream out = <span class="keyword">new</span> FileOutputStream(dist);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span> * <span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read() 最多读取 buffer.length 个字节</span></span><br><span class="line">    <span class="comment">// 返回的是实际读取的个数</span></span><br><span class="line">    <span class="comment">// 返回 -1 的时候表示读到 eof，即文件尾</span></span><br><span class="line">    <span class="keyword">while</span> ((cnt = in.read(buffer, <span class="number">0</span>, buffer.length)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        out.write(buffer, <span class="number">0</span>, cnt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    in.close();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="装饰者模式-（待整理详细相关内容）"><a href="#装饰者模式-（待整理详细相关内容）" class="headerlink" title="装饰者模式 （待整理详细相关内容）"></a>装饰者模式 （待整理详细相关内容）</h3><p>Java I/O 使用了装饰者模式来实现。以 InputStream 为例，</p>
<ul>
<li>InputStream 是抽象组件；</li>
<li>FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作；</li>
<li>FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9709694b-db05-4cce-8d2f-1c8b09f4d921.png" alt="img"></h2><p>实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">BufferedInputStream bufferedInputStream = <span class="keyword">new</span> BufferedInputStream(fileInputStream);</span><br></pre></td></tr></table></figure>

<p>DataInputStream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型。</p>
<h2 id="四、字符操作"><a href="#四、字符操作" class="headerlink" title="四、字符操作"></a>四、字符操作</h2><h3 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h3><p>编码就是把字符转换为字节，而解码是把字节重新组合成字符。</p>
<p>如果编码和解码过程使用不同的编码方式那么就出现了乱码。</p>
<ul>
<li>GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节；</li>
<li>UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节；</li>
<li>UTF-16be 编码中，中文字符和英文字符都占 2 个字节。</li>
</ul>
<p>UTF-16be 中的 be 指的是 Big Endian，也就是大端。相应地也有 UTF-16le，le 指的是 Little Endian，也就是小端。</p>
<p>Java 的内存编码使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。</p>
<h3 id="String-的编码方式"><a href="#String-的编码方式" class="headerlink" title="String 的编码方式"></a>String 的编码方式</h3><p>String 可以看成一个字符序列，可以指定一个编码方式将它编码为字节序列，也可以指定一个编码方式将一个字节序列解码为 String。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;中文&quot;</span>;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = str1.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(bytes, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">System.out.println(str2);</span><br></pre></td></tr></table></figure>

<p>在调用无参数 getBytes() 方法时，默认的编码方式不是 UTF-16be。双字节编码的好处是可以使用一个 char 存储中文和英文，而将 String 转为 bytes[] 字节数组就不再需要这个好处，因此也就不再需要双字节编码。getBytes() 的默认编码方式与平台有关，一般为 UTF-8。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = str1.getBytes();</span><br></pre></td></tr></table></figure>

<h3 id="Reader-与-Writer"><a href="#Reader-与-Writer" class="headerlink" title="Reader 与 Writer"></a>Reader 与 Writer</h3><p>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。</p>
<ul>
<li>InputStreamReader 实现从字节流解码成字符流；</li>
<li>OutputStreamWriter 实现字符流编码成为字节流。</li>
</ul>
<h3 id="实现逐行输出文本文件的内容"><a href="#实现逐行输出文本文件的内容" class="headerlink" title="实现逐行输出文本文件的内容"></a>实现逐行输出文本文件的内容</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFileContent</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    FileReader fileReader = <span class="keyword">new</span> FileReader(filePath);</span><br><span class="line">    BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(fileReader);</span><br><span class="line"></span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 装饰者模式使得 BufferedReader 组合了一个 Reader 对象</span></span><br><span class="line">    <span class="comment">// 在调用 BufferedReader 的 close() 方法时会去调用 Reader 的 close() 方法</span></span><br><span class="line">    <span class="comment">// 因此只要一个 close() 调用即可</span></span><br><span class="line">    bufferedReader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、对象操作"><a href="#五、对象操作" class="headerlink" title="五、对象操作"></a>五、对象操作</h2><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>序列化就是将一个对象转换成字节序列，方便存储和传输。</p>
<ul>
<li>序列化：ObjectOutputStream.writeObject()</li>
<li>反序列化：ObjectInputStream.readObject()</li>
</ul>
<p>不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。</p>
<h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p>序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    A a1 = <span class="keyword">new</span> A(<span class="number">123</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    String objectFile = <span class="string">&quot;file/a1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(objectFile));</span><br><span class="line">    objectOutputStream.writeObject(a1);</span><br><span class="line">    objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">    ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(objectFile));</span><br><span class="line">    A a2 = (A) objectInputStream.readObject();</span><br><span class="line">    objectInputStream.close();</span><br><span class="line">    System.out.println(a2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> String y;</span><br><span class="line"></span><br><span class="line">    A(<span class="keyword">int</span> x, String y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;x = &quot;</span> + x + <span class="string">&quot;  &quot;</span> + <span class="string">&quot;y = &quot;</span> + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h3><p>transient 关键字可以使一些属性不会被序列化。</p>
<p>ArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure>

<h2 id="六、网络操作"><a href="#六、网络操作" class="headerlink" title="六、网络操作"></a>六、网络操作</h2><p>Java 中的网络支持：</p>
<ul>
<li>InetAddress：用于表示网络上的硬件资源，即 IP 地址；</li>
<li>URL：统一资源定位符；</li>
<li>Sockets：使用 TCP 协议实现网络通信；</li>
<li>Datagram：使用 UDP 协议实现网络通信。</li>
</ul>
<h3 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h3><p>没有公有的构造函数，只能通过静态方法来创建实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InetAddress.getByName(String host);</span><br><span class="line">InetAddress.getByAddress(<span class="keyword">byte</span>[] address);</span><br></pre></td></tr></table></figure>

<h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>可以直接从 URL 中读取字节流数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    URL url = <span class="keyword">new</span> URL(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 字节流 */</span></span><br><span class="line">    InputStream is = url.openStream();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 字符流 */</span></span><br><span class="line">    InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(is, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 提供缓存功能 */</span></span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line"></span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    br.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Sockets"><a href="#Sockets" class="headerlink" title="Sockets"></a>Sockets</h3><ul>
<li>ServerSocket：服务器端类</li>
<li>Socket：客户端类</li>
<li>服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。</li>
</ul>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1e6affc4-18e5-4596-96ef-fb84c63bf88a.png" alt="img"></p>
<h3 id="Datagram"><a href="#Datagram" class="headerlink" title="Datagram"></a>Datagram</h3><ul>
<li>DatagramSocket：通信类</li>
<li>DatagramPacket：数据包类</li>
</ul>
<h2 id="七、NIO"><a href="#七、NIO" class="headerlink" title="七、NIO"></a>七、NIO</h2><p>新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。</p>
<h3 id="流与块"><a href="#流与块" class="headerlink" title="流与块"></a>流与块</h3><p>I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。</p>
<p>面向流的 I/O 一次处理一个字节数据：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。</p>
<p>面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</p>
<p>I/O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。</p>
<h3 id="通道与缓冲区"><a href="#通道与缓冲区" class="headerlink" title="通道与缓冲区"></a>通道与缓冲区</h3><h4 id="1-通道"><a href="#1-通道" class="headerlink" title="1. 通道"></a>1. 通道</h4><p>通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。</p>
<p>通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。</p>
<p>通道包括以下类型：</p>
<ul>
<li>FileChannel：从文件中读写数据；</li>
<li>DatagramChannel：通过 UDP 读写网络中数据；</li>
<li>SocketChannel：通过 TCP 读写网络中数据；</li>
<li>ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</li>
</ul>
<h4 id="2-缓冲区"><a href="#2-缓冲区" class="headerlink" title="2. 缓冲区"></a>2. 缓冲区</h4><p>发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。</p>
<p>缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p>
<p>缓冲区包括以下类型：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
</ul>
<h3 id="缓冲区状态变量"><a href="#缓冲区状态变量" class="headerlink" title="缓冲区状态变量"></a>缓冲区状态变量</h3><ul>
<li>capacity：最大容量；</li>
<li>position：当前已经读写的字节数；</li>
<li>limit：还可以读写的字节数。</li>
</ul>
<p>状态变量的改变过程举例：</p>
<p>① 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1bea398f-17a7-4f67-a90b-9e2d243eaa9a.png" alt="img"></p>
<p>② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 为 5，limit 保持不变。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/80804f52-8815-4096-b506-48eef3eed5c6.png" alt="img"></p>
<p>③ 在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/952e06bd-5a65-4cab-82e4-dd1536462f38.png" alt="img"></p>
<p>④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b5bdcbe2-b958-4aef-9151-6ad963cb28b4.png" alt="img"></p>
<p>⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/67bf5487-c45d-49b6-b9c0-a058d8c68902.png" alt="img"></p>
<h3 id="文件-NIO-实例"><a href="#文件-NIO-实例" class="headerlink" title="文件 NIO 实例"></a>文件 NIO 实例</h3><p>以下展示了使用 NIO 快速复制文件的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fastCopy</span><span class="params">(String src, String dist)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获得源文件的输入字节流 */</span></span><br><span class="line">    FileInputStream fin = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取输入字节流的文件通道 */</span></span><br><span class="line">    FileChannel fcin = fin.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取目标文件的输出字节流 */</span></span><br><span class="line">    FileOutputStream fout = <span class="keyword">new</span> FileOutputStream(dist);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取输出字节流的文件通道 */</span></span><br><span class="line">    FileChannel fcout = fout.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为缓冲区分配 1024 个字节 */</span></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 从输入通道中读取数据到缓冲区中 */</span></span><br><span class="line">        <span class="keyword">int</span> r = fcin.read(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* read() 返回 -1 表示 EOF */</span></span><br><span class="line">        <span class="keyword">if</span> (r == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 切换读写 */</span></span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 把缓冲区的内容写入输出文件中 */</span></span><br><span class="line">        fcout.write(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 清空缓冲区 */</span></span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。</p>
<p>NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。</p>
<p>通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。</p>
<p>因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能。</p>
<p>应该注意的是，只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/093f9e57-429c-413a-83ee-c689ba596cef.png" alt="img"></p>
<h4 id="1-创建选择器"><a href="#1-创建选择器" class="headerlink" title="1. 创建选择器"></a>1. 创建选择器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure>

<h4 id="2-将通道注册到选择器上"><a href="#2-将通道注册到选择器上" class="headerlink" title="2. 将通道注册到选择器上"></a>2. 将通道注册到选择器上</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocketChannel ssChannel = ServerSocketChannel.open();</span><br><span class="line">ssChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>

<p>通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。</p>
<p>在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类：</p>
<ul>
<li>SelectionKey.OP_CONNECT</li>
<li>SelectionKey.OP_ACCEPT</li>
<li>SelectionKey.OP_READ</li>
<li>SelectionKey.OP_WRITE</li>
</ul>
<p>它们在 SelectionKey 的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_READ = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WRITE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_CONNECT = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_ACCEPT = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>

<h4 id="3-监听事件"><a href="#3-监听事件" class="headerlink" title="3. 监听事件"></a>3. 监听事件</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = selector.select();</span><br></pre></td></tr></table></figure>

<p>使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。</p>
<h4 id="4-获取到达的事件"><a href="#4-获取到达的事件" class="headerlink" title="4. 获取到达的事件"></a>4. 获取到达的事件</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line"><span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-事件循环"><a href="#5-事件循环" class="headerlink" title="5. 事件循环"></a>5. 事件循环</h4><p>因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> num = selector.select();</span><br><span class="line">    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line">    <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = keyIterator.next();</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        keyIterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="套接字-NIO-实例"><a href="#套接字-NIO-实例" class="headerlink" title="套接字 NIO 实例"></a>套接字 NIO 实例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        ServerSocketChannel ssChannel = ServerSocketChannel.open();</span><br><span class="line">        ssChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        ServerSocket serverSocket = ssChannel.socket();</span><br><span class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">        serverSocket.bind(address);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">                SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line"></span><br><span class="line">                    ServerSocketChannel ssChannel1 = (ServerSocketChannel) key.channel();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 服务器会为每个新连接创建一个 SocketChannel</span></span><br><span class="line">                    SocketChannel sChannel = ssChannel1.accept();</span><br><span class="line">                    sChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 这个新连接主要用于从客户端读取数据</span></span><br><span class="line">                    sChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line"></span><br><span class="line">                    SocketChannel sChannel = (SocketChannel) key.channel();</span><br><span class="line">                    System.out.println(readDataFromSocketChannel(sChannel));</span><br><span class="line">                    sChannel.close();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">readDataFromSocketChannel</span><span class="params">(SocketChannel sChannel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        StringBuilder data = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="keyword">int</span> n = sChannel.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (n == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="keyword">int</span> limit = buffer.limit();</span><br><span class="line">            <span class="keyword">char</span>[] dst = <span class="keyword">new</span> <span class="keyword">char</span>[limit];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i++) &#123;</span><br><span class="line">                dst[i] = (<span class="keyword">char</span>) buffer.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            data.append(dst);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">        OutputStream out = socket.getOutputStream();</span><br><span class="line">        String s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        out.write(s.getBytes());</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><p>内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。</p>
<p>向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。</p>
<p>下面代码行将文件的前 1024 个字节映射到内存中，map() 方法返回一个 MappedByteBuffer，它是 ByteBuffer 的子类。因此，可以像使用其他任何 ByteBuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">1024</span>);</span><br></pre></td></tr></table></figure>

<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>NIO 与普通 I/O 的区别主要有以下两点：</p>
<ul>
<li>NIO 是非阻塞的；</li>
<li>NIO 面向块，I/O 面向流。</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>netty学习第三天</title>
    <url>/2021/05/27/netty%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%A4%A9/</url>
    <content><![CDATA[<h2 id="FileChannel类"><a href="#FileChannel类" class="headerlink" title="FileChannel类"></a>FileChannel类</h2><p>FileChannel主要用来对本地文件进行IO操作，常用的方法有</p>
<ol>
<li>public int read(ByteBuffer dst)，从通道读取数据到缓冲区中</li>
<li>public int write(ByteBuffer src)，把缓冲区的数据写到通道中</li>
<li>public long transferFrom(ReadableByteChannel src, long position, long count)，从目标通道中复制数据到当前通道</li>
<li>public long transferTo(long position, long count, WritableByteChannel target )，把数据从当前通道复制给目标通道</li>
</ol>
<h2 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h2><p>RandomAccessFile是java Io体系中功能最丰富的文件内容访问类。<br>即可以读取文件内容，也可以向文件中写入内容。<br>但是和其他输入/输入流不同的是，程序可以直接跳到文件的任意位置来读写数据。<a id="more"></a></p>
<h3 id="使用ByteBuffer复制文件"><a href="#使用ByteBuffer复制文件" class="headerlink" title="使用ByteBuffer复制文件"></a>使用ByteBuffer复制文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyByBuffer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;f:\\testNIO20210526.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//创建文件输入流，读取文件内容</span></span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        <span class="comment">//获取通道</span></span><br><span class="line">        FileChannel fileChannel = fileInputStream.getChannel();</span><br><span class="line">        <span class="comment">//创建文件输出流</span></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;f:\\testNIO20210526-copy.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//获取通道</span></span><br><span class="line">        FileChannel fileChannel1 = fileOutputStream.getChannel();</span><br><span class="line">        <span class="comment">//创建缓冲区</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">//每次读取的时候需要清空buffer</span></span><br><span class="line">                byteBuffer.clear();</span><br><span class="line">                <span class="comment">//将通道中的数据读取到buffer中</span></span><br><span class="line">                <span class="keyword">int</span> read = fileChannel.read(byteBuffer);</span><br><span class="line">                <span class="keyword">if</span>(read == -<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//没有数据可读，退出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;本次读入的大小为：&quot;</span>+read);</span><br><span class="line">                <span class="comment">//将buffer切换为读模式</span></span><br><span class="line">                byteBuffer.flip();</span><br><span class="line">                <span class="comment">//把buffer中的数据写到通道中</span></span><br><span class="line">                fileChannel1.write(byteBuffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭文件输出流与输入流</span></span><br><span class="line">            fileOutputStream.close();</span><br><span class="line">            fileInputStream.close();</span><br><span class="line">            System.out.println(<span class="string">&quot;复制成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用FileChannel的TransferFrom复制文件"><a href="#使用FileChannel的TransferFrom复制文件" class="headerlink" title="使用FileChannel的TransferFrom复制文件"></a>使用FileChannel的TransferFrom复制文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferFrom</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\users\\1903040093\\Downloads\\微信截图_20210527161018.png&quot;</span>);</span><br><span class="line">        FileChannel sourceChannel = fileInputStream.getChannel();</span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\users\\1903040093\\Downloads\\微信截图_20210527161018_副本.png&quot;</span>);</span><br><span class="line">        FileChannel targetChannel = fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        targetChannel.transferFrom(sourceChannel,<span class="number">0</span>,sourceChannel.size());</span><br><span class="line">        sourceChannel.close();</span><br><span class="line">        targetChannel.close();</span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用MappedByteBuffer直接从堆外内存中修改文件，操作系统不需要拷贝一次"><a href="#使用MappedByteBuffer直接从堆外内存中修改文件，操作系统不需要拷贝一次" class="headerlink" title="使用MappedByteBuffer直接从堆外内存中修改文件，操作系统不需要拷贝一次"></a>使用MappedByteBuffer直接从堆外内存中修改文件，操作系统不需要拷贝一次</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedByteBufferTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * RandomAccessFile是java Io体系中功能最丰富的文件内容访问类。</span></span><br><span class="line"><span class="comment">         * 即可以读取文件内容，也可以向文件中写入内容。</span></span><br><span class="line"><span class="comment">         * 但是和其他输入/输入流不同的是，程序可以直接跳到文件的任意位置来读写数据。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;f:\\testNIO20210526.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="comment">//获取通道</span></span><br><span class="line">        FileChannel fileChannel = randomAccessFile.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数1：FileChannel.MapMode.READ_WRITE 代表读写模式</span></span><br><span class="line"><span class="comment">         * 参数2：代表可以直接修改的起始位置</span></span><br><span class="line"><span class="comment">         * 参数3：代表总共可以修改多少个字节</span></span><br><span class="line"><span class="comment">         * 实际类型为：DirectByteBuffer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        MappedByteBuffer mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        mappedByteBuffer.put(<span class="number">0</span>,(<span class="keyword">byte</span>) <span class="string">&#x27;Y&#x27;</span>);</span><br><span class="line">        mappedByteBuffer.put(<span class="number">3</span>,(<span class="keyword">byte</span>) <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">        <span class="comment">//mappedByteBuffer.put(5,(byte) &#x27;哦&#x27;);//会导致数组下标越界异常 IndexOutOfBoundsExpection</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭文件流</span></span><br><span class="line">        randomAccessFile.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用多个缓冲区接收数据（buffer的分散于聚集）"><a href="#使用多个缓冲区接收数据（buffer的分散于聚集）" class="headerlink" title="使用多个缓冲区接收数据（buffer的分散于聚集）"></a>使用多个缓冲区接收数据（buffer的分散于聚集）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScatteringAndGatteringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建ServerSocketChannel</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">//绑定端口</span></span><br><span class="line">        serverSocketChannel.socket().bind(inetSocketAddress);</span><br><span class="line">        <span class="comment">//创建Buffer数组</span></span><br><span class="line">        ByteBuffer[] byteBuffers = <span class="keyword">new</span> ByteBuffer[<span class="number">2</span>];</span><br><span class="line">        byteBuffers[<span class="number">0</span>] = ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">        byteBuffers[<span class="number">1</span>] = ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待客户端连接</span></span><br><span class="line">        SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环读取</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> byteRead = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> read = socketChannel.read(byteBuffers);</span><br><span class="line">            byteRead += read;</span><br><span class="line">            Arrays.asList(byteBuffers).stream().map(byteBuffer -&gt; <span class="string">&quot;position:&quot;</span>+byteBuffer.position()+<span class="string">&quot;,limit:&quot;</span>+byteBuffer.limit()).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">            Arrays.asList(byteBuffers).forEach(byteBuffer -&gt; byteBuffer.flip());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> byteWrite = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> write = socketChannel.write(byteBuffers);</span><br><span class="line">            byteWrite += write;</span><br><span class="line"></span><br><span class="line">            Arrays.asList(byteBuffers).forEach(byteBuffer -&gt; byteBuffer.clear());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;输入字节数为：&quot;</span>+byteRead+<span class="string">&quot;，输出字节数为：&quot;</span>+byteWrite);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>今天先这样了 打卡第四天了 明天继续 开始对IO操作有了一个整体的比较清楚的认识了！！惭愧</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title>netty学习第四天</title>
    <url>/2021/05/28/netty%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E5%A4%A9/</url>
    <content><![CDATA[<h2 id="selector选择器"><a href="#selector选择器" class="headerlink" title="selector选择器"></a>selector选择器</h2><ul>
<li><p>selector能够检测多个注册的通道上是否有事件发生（注意：多个channel以时间的方式可以注册到同一个selector），如果有时间发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求</p>
</li>
<li><p>只有在通道真正有读写事件发生的时候就会进行读写，大大减小系统开销</p>
</li>
<li><p>避免多线程之间的上下文切换导致的开销</p>
</li>
</ul>
<h2 id="selector相关方法"><a href="#selector相关方法" class="headerlink" title="selector相关方法"></a>selector相关方法</h2><ul>
<li><p>selector.select();//阻塞，必须要有一个通道注册上了才会返回</p>
</li>
<li><p>selector.select(1000);//阻塞1000毫秒，在1000毫秒后返回</p>
</li>
<li><p>selector.weakup();//唤醒selector</p>
</li>
<li><p>selector.selectNow();//不阻塞立马返回</p>
</li>
</ul>
<h2 id="写个Demo"><a href="#写个Demo" class="headerlink" title="写个Demo"></a>写个Demo</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建ServerSocketChannel 并绑定端口号6666</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">6666</span>));</span><br><span class="line">        <span class="comment">//将通道设置为非阻塞</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Selector</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//serverSocketChannel注册到selector上</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环监听客户端连接</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//查看serverSocketChannel是否有请求进来</span></span><br><span class="line">            <span class="keyword">if</span>(selector.select(<span class="number">1000</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//等待一秒</span></span><br><span class="line">                System.out.println(<span class="string">&quot;服务器等待了1秒，无连接&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果有事件发生了</span></span><br><span class="line">            <span class="comment">//selector.selectedKeys()返回关注事件的集合，通过selectedKeys可以反向获取通道</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            <span class="comment">//对selectionKeys进行遍历</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                <span class="comment">//获取SelectionKey</span></span><br><span class="line">                SelectionKey selectionKey = iterator.next();</span><br><span class="line">                <span class="comment">//如果是请求事件</span></span><br><span class="line">                <span class="keyword">if</span>(selectionKey.isAcceptable())&#123;</span><br><span class="line">                    <span class="comment">//创建socketChannel，由于已经可以确定是有请求进来了，所以才创建这个连接，而不是和BIO那样无法得知客户端什么时候需要连接</span></span><br><span class="line">                    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                    <span class="comment">//这里也是一样需要将socketChannel设置为非阻塞</span></span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">//将socketChannel也注册到selector上，并分配一个buffer进行绑定</span></span><br><span class="line">                    socketChannel.register(selector,SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果是读事件</span></span><br><span class="line">                <span class="keyword">if</span>(selectionKey.isReadable())&#123;</span><br><span class="line">                    <span class="comment">//通过selectionKey反向获取通道，需要强转为socketchannel</span></span><br><span class="line">                    SocketChannel channel = (SocketChannel)selectionKey.channel();</span><br><span class="line">                    <span class="comment">//获取该channel关联的buffer</span></span><br><span class="line">                    ByteBuffer buffer = (ByteBuffer)selectionKey.attachment();</span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">                &#125;</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//创建socketChannel</span></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        <span class="comment">//设置为非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//提供服务器端的ip和端口</span></span><br><span class="line">        InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        <span class="keyword">if</span>(!socketChannel.connect(inetSocketAddress))&#123;</span><br><span class="line">            <span class="comment">//如果连接不成功</span></span><br><span class="line">            <span class="keyword">while</span> (!socketChannel.finishConnect())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;由于连接需要时间，现在还没完成，这里可以继续处理其他事情，不会阻塞&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//连接成功，开始发送数据</span></span><br><span class="line">        String s = <span class="string">&quot;hello, 今天在干嘛呀&quot;</span>;</span><br><span class="line">        <span class="comment">//ByteBuffer.wrap();这个方法可以直接包裹字节数组，不需要自己手动申请buffer空间</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.wrap(s.getBytes());</span><br><span class="line">        <span class="comment">//将buffer中的数据写到通道中，由于通道已连服务端，所以会直接发过去</span></span><br><span class="line">        socketChannel.write(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>四天了 总算对java I/O有一个大致的了解了，害</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
</search>
